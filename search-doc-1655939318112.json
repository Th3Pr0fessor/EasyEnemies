[{"title":"KnitClient","type":0,"sectionRef":"#","url":"api/KnitClient","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"KnitClient","url":"api/KnitClient#types","content":" "},{"title":"Middleware​","type":1,"pageTitle":"KnitClient","url":"api/KnitClient#Middleware","content":"&lt;/&gt; interface Middleware { Inbound: ClientMiddleware? Outbound: ClientMiddleware? }   "},{"title":"ClientMiddlewareFn​","type":1,"pageTitle":"KnitClient","url":"api/KnitClient#ClientMiddlewareFn","content":"&lt;/&gt; type ClientMiddlewareFn = (args: {any}) → ( shouldContinue: boolean, ...: any ) For more info, see ClientComm documentation.  "},{"title":"ClientMiddleware​","type":1,"pageTitle":"KnitClient","url":"api/KnitClient#ClientMiddleware","content":"&lt;/&gt; type ClientMiddleware = {ClientMiddlewareFn} An array of client middleware functions.  "},{"title":"PerServiceMiddleware​","type":1,"pageTitle":"KnitClient","url":"api/KnitClient#PerServiceMiddleware","content":"&lt;/&gt; type PerServiceMiddleware = {[string]: Middleware}   "},{"title":"ControllerDef​","type":1,"pageTitle":"KnitClient","url":"api/KnitClient#ControllerDef","content":"&lt;/&gt; interface ControllerDef { Name: string [any]: any } Used to define a controller when creating it in CreateController.  "},{"title":"Controller​","type":1,"pageTitle":"KnitClient","url":"api/KnitClient#Controller","content":"&lt;/&gt; interface Controller { Name: string [any]: any }   "},{"title":"KnitOptions​","type":1,"pageTitle":"KnitClient","url":"api/KnitClient#KnitOptions","content":"&lt;/&gt; interface KnitOptions { ServicePromises: boolean? Middleware: Middleware? PerServiceMiddleware: PerServiceMiddleware? } ServicePromises defaults to true and indicates if service methods use promises. Each service will go through the defined middleware, unless the service has middleware defined in PerServiceMiddleware.  "},{"title":"Properties​","type":1,"pageTitle":"KnitClient","url":"api/KnitClient#properties","content":" "},{"title":"Player​","type":1,"pageTitle":"KnitClient","url":"api/KnitClient#Player","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; KnitClient.Player: Player  Reference to the LocalPlayer.  "},{"title":"Util​","type":1,"pageTitle":"KnitClient","url":"api/KnitClient#Util","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; KnitClient.Util: Folder  References the Util folder. Should only be accessed when using Knit as a standalone module. If using Knit from Wally, modules should just be pulled in via Wally instead of relying on Knit's Util folder, as this folder only contains what is necessary for Knit to run in Wally mode. "},{"title":"Functions​","type":1,"pageTitle":"KnitClient","url":"api/KnitClient#functions","content":" "},{"title":"CreateController​","type":1,"pageTitle":"KnitClient","url":"api/KnitClient#CreateController","content":"&lt;/&gt; KnitClient.CreateController(controllerDef: ControllerDef) → Controller Creates a new controller. caution Controllers must be created before calling Knit.Start(). -- Create a controller local MyController = Knit.CreateController { Name = &quot;MyController&quot;, } function MyController:KnitStart() print(&quot;MyController started&quot;) end function MyController:KnitInit() print(&quot;MyController initialized&quot;) end   "},{"title":"AddControllers​","type":1,"pageTitle":"KnitClient","url":"api/KnitClient#AddControllers","content":"&lt;/&gt; KnitClient.AddControllers(parent: Instance ) → {Controller} Requires all the modules that are children of the given parent. This is an easy way to quickly load all controllers that might be in a folder. Knit.AddControllers(somewhere.Controllers)   "},{"title":"AddControllersDeep​","type":1,"pageTitle":"KnitClient","url":"api/KnitClient#AddControllersDeep","content":"&lt;/&gt; KnitClient.AddControllersDeep(parent: Instance ) → {Controller} Requires all the modules that are descendants of the given parent.  "},{"title":"GetService​","type":1,"pageTitle":"KnitClient","url":"api/KnitClient#GetService","content":"&lt;/&gt; KnitClient.GetService(serviceName: string) → Service "},{"title":"Types","type":1,"pageTitle":"KnitClient","url":"api/KnitClient##","content":""},{"title":"​","type":1,"pageTitle":"KnitClient","url":"api/KnitClient#Service","content":"interface Service { [any]: any }  Returns a Service object which is a reflection of the remote objects within the Client table of the given service. Throws an error if the service is not found. If a service's Client table contains RemoteSignals and/or RemoteProperties, these values are reflected asClientRemoteSignals and ClientRemoteProperties. -- Server-side service creation: local MyService = Knit.CreateService { Name = &quot;MyService&quot;, Client = { MySignal = Knit.CreateSignal(), MyProperty = Knit.CreateProperty(&quot;Hello&quot;), }, } function MyService:AddOne(player, number) return number + 1 end ------------------------------------------------- -- Client-side service reflection: local MyService = Knit.GetService(&quot;MyService&quot;) -- Call a method: local num = MyService:AddOne(5) --&gt; 6 -- Fire a signal to the server: MyService.MySignal:Fire(&quot;Hello&quot;) -- Listen for signals from the server: MyService.MySignal:Connect(function(message) print(message) end) -- Observe the initial value and changes to properties: MyService.MyProperty:Observe(function(value) print(value) end) caution Services are only exposed to the client if the service has remote-based content in the Client table. If not, the service will not be visible to the client. KnitClient.GetService will only work on services that expose remote-based content on their Client tables.  "},{"title":"GetController​","type":1,"pageTitle":"KnitClient","url":"api/KnitClient#GetController","content":"&lt;/&gt; KnitClient.GetController(controllerName: string) → Controller Gets the controller by name. Throws an error if the controller is not found.  "},{"title":"Start​","type":1,"pageTitle":"KnitClient","url":"api/KnitClient#Start","content":"&lt;/&gt; KnitClient.Start(options: KnitOptions?) → Promise Starts Knit. Should only be called once per client. Knit.Start():andThen(function() print(&quot;Knit started!&quot;) end):catch(warn) By default, service methods exposed to the client will return promises. To change this behavior, set the ServicePromises option to false: Knit.Start({ServicePromises = false}):andThen(function() print(&quot;Knit started!&quot;) end):catch(warn)   "},{"title":"OnStart​","type":1,"pageTitle":"KnitClient","url":"api/KnitClient#OnStart","content":"&lt;/&gt; KnitClient.OnStart() → Promise Returns a promise that is resolved once Knit has started. This is useful for any code that needs to tie into Knit controllers but is not the script that called Start. Knit.OnStart():andThen(function() local MyController = Knit.GetController(&quot;MyController&quot;) MyController:DoSomething() end):catch(warn)  "},{"title":"KnitServer","type":0,"sectionRef":"#","url":"api/KnitServer","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"KnitServer","url":"api/KnitServer#types","content":" "},{"title":"Middleware​","type":1,"pageTitle":"KnitServer","url":"api/KnitServer#Middleware","content":"&lt;/&gt; interface Middleware { Inbound: ServerMiddleware? Outbound: ServerMiddleware? }   "},{"title":"ServerMiddlewareFn​","type":1,"pageTitle":"KnitServer","url":"api/KnitServer#ServerMiddlewareFn","content":"&lt;/&gt; type ServerMiddlewareFn = ( player: Player , args: {any} ) → ( shouldContinue: boolean, ...: any ) For more info, see ServerComm documentation.  "},{"title":"ServerMiddleware​","type":1,"pageTitle":"KnitServer","url":"api/KnitServer#ServerMiddleware","content":"&lt;/&gt; type ServerMiddleware = {ServerMiddlewareFn} An array of server middleware functions.  "},{"title":"ServiceDef​","type":1,"pageTitle":"KnitServer","url":"api/KnitServer#ServiceDef","content":"&lt;/&gt; interface ServiceDef { Name: string Client: table? Middleware: Middleware? [any]: any } Used to define a service when creating it in CreateService. The middleware tables provided will be used instead of the Knit-level middleware (if any). This allows fine-tuning each service's middleware. These can also be left out or nil to not include middleware.  "},{"title":"Service​","type":1,"pageTitle":"KnitServer","url":"api/KnitServer#Service","content":"&lt;/&gt; interface Service { Name: string Client: ServiceClient KnitComm: Comm [any]: any }   "},{"title":"ServiceClient​","type":1,"pageTitle":"KnitServer","url":"api/KnitServer#ServiceClient","content":"&lt;/&gt; interface ServiceClient { Server: Service [any]: any }   "},{"title":"KnitOptions​","type":1,"pageTitle":"KnitServer","url":"api/KnitServer#KnitOptions","content":"&lt;/&gt; interface KnitOptions { Middleware: Middleware? }  Middleware will apply to all services except ones that define their own middleware.  "},{"title":"Properties​","type":1,"pageTitle":"KnitServer","url":"api/KnitServer#properties","content":" "},{"title":"Util​","type":1,"pageTitle":"KnitServer","url":"api/KnitServer#Util","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; KnitServer.Util: Folder  References the Util folder. Should only be accessed when using Knit as a standalone module. If using Knit from Wally, modules should just be pulled in via Wally instead of relying on Knit's Util folder, as this folder only contains what is necessary for Knit to run in Wally mode. "},{"title":"Functions​","type":1,"pageTitle":"KnitServer","url":"api/KnitServer#functions","content":" "},{"title":"CreateService​","type":1,"pageTitle":"KnitServer","url":"api/KnitServer#CreateService","content":"&lt;/&gt; KnitServer.CreateService(serviceDef: ServiceDef) → Service Constructs a new service. caution Services must be created before calling Knit.Start(). -- Create a service local MyService = Knit.CreateService { Name = &quot;MyService&quot;, Client = {}, } -- Expose a ToAllCaps remote function to the clients function MyService.Client:ToAllCaps(player, msg) return msg:upper() end -- Knit will call KnitStart after all services have been initialized function MyService:KnitStart() print(&quot;MyService started&quot;) end -- Knit will call KnitInit when Knit is first started function MyService:KnitInit() print(&quot;MyService initialize&quot;) end   "},{"title":"AddServices​","type":1,"pageTitle":"KnitServer","url":"api/KnitServer#AddServices","content":"&lt;/&gt; KnitServer.AddServices(parent: Instance ) → {Service} Requires all the modules that are children of the given parent. This is an easy way to quickly load all services that might be in a folder. Knit.AddServices(somewhere.Services)   "},{"title":"AddServicesDeep​","type":1,"pageTitle":"KnitServer","url":"api/KnitServer#AddServicesDeep","content":"&lt;/&gt; KnitServer.AddServicesDeep(parent: Instance ) → {Service} Requires all the modules that are descendants of the given parent.  "},{"title":"GetService​","type":1,"pageTitle":"KnitServer","url":"api/KnitServer#GetService","content":"&lt;/&gt; KnitServer.GetService(serviceName: string) → Service Gets the service by name. Throws an error if the service is not found.  "},{"title":"CreateSignal​","type":1,"pageTitle":"KnitServer","url":"api/KnitServer#CreateSignal","content":"&lt;/&gt; KnitServer.CreateSignal() → SIGNAL_MARKER Returns a marker that will transform the current key into a RemoteSignal once the service is created. Should only be called within the Client table of a service. See RemoteSignal documentation for more info. local MyService = Knit.CreateService { Name = &quot;MyService&quot;, Client = { -- Create the signal marker, which will turn into a -- RemoteSignal when Knit.Start() is called: MySignal = Knit.CreateSignal(), }, } function MyService:KnitInit() -- Connect to the signal: self.Client.MySignal:Connect(function(player, ...) end) end   "},{"title":"CreateProperty​","type":1,"pageTitle":"KnitServer","url":"api/KnitServer#CreateProperty","content":"&lt;/&gt; KnitServer.CreateProperty(initialValue: any) → PROPERTY_MARKER Returns a marker that will transform the current key into a RemoteProperty once the service is created. Should only be called within the Client table of a service. An initial value can be passed along as well. RemoteProperties are great for replicating data to all of the clients. Different data can also be set per client. See RemoteProperty documentation for more info. local MyService = Knit.CreateService { Name = &quot;MyService&quot;, Client = { -- Create the property marker, which will turn into a -- RemoteProperty when Knit.Start() is called: MyProperty = Knit.CreateProperty(&quot;HelloWorld&quot;), }, } function MyService:KnitInit() -- Change the value of the property: self.Client.MyProperty:Set(&quot;HelloWorldAgain&quot;) end   "},{"title":"Start​","type":1,"pageTitle":"KnitServer","url":"api/KnitServer#Start","content":"&lt;/&gt; KnitServer.Start(options: KnitOptions?) → Promise Starts Knit. Should only be called once. Optionally, KnitOptions can be passed in order to set Knit's custom configurations. caution Be sure that all services have been created before calling Start. Services cannot be added later. Knit.Start():andThen(function() print(&quot;Knit started!&quot;) end):catch(warn) Example of Knit started with options: Knit.Start({ Middleware = { Inbound = { function(player, args) print(&quot;Player is giving following args to server:&quot;, args) return true end }, }, }):andThen(function() print(&quot;Knit started!&quot;) end):catch(warn)   "},{"title":"OnStart​","type":1,"pageTitle":"KnitServer","url":"api/KnitServer#OnStart","content":"&lt;/&gt; KnitServer.OnStart() → Promise Returns a promise that is resolved once Knit has started. This is useful for any code that needs to tie into Knit services but is not the script that called Start. Knit.OnStart():andThen(function() local MyService = Knit.Services.MyService MyService:DoSomething() end):catch(warn)  "},{"title":"Examples","type":0,"sectionRef":"#","url":"docs/examples","content":"","keywords":""},{"title":"Start All Services​","type":1,"pageTitle":"Examples","url":"docs/examples#start-all-services","content":"A useful pattern is to keep all service modules within a folder. The script that starts Knit can then require all of these at once. Let's say we have a directory structure like such: Server KnitRuntime [Script]Services [Folder] MyService [Module]AnotherService [Module]HelloService [Module] We can write our KnitRuntime script as such: local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) -- Load all services: for _,v in ipairs(script.Parent.Services:GetDescendants()) do if (v:IsA(&quot;ModuleScript&quot;)) then require(v) end end Knit.Start():catch(warn) Copy Alternatively, we can use Knit.AddServices or Knit.AddServicesDeep to load all of the services without writing a loop. It scans and loads all ModuleScripts found and passes them to Knit.CreateService: local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) -- Load all services within 'Services': Knit.AddServices(script.Parent.Services) -- Load all services (the Deep version scans all descendants of the passed instance): Knit.AddServicesDeep(script.Parent.OtherServices) Knit.Start():catch(warn) Copy tip This same design practice can also be done on the client with controllers. Either loop through and collect controllers or use the Knit.AddControllers or Knit.AddControllersDeep function.  "},{"title":"Expose a Collection of Modules​","type":1,"pageTitle":"Examples","url":"docs/examples#expose-a-collection-of-modules","content":"Like Knit.Util, we can expose a collection of modules to our codebase. This is very simple. All we need to do is add Knit.WHATEVER and point it to a folder of ModuleScripts. For instance, if we had a folder of modules at ReplicatedStorage.MyModules, we can expose this within our main runtime script: local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) -- Expose our MyModules folder: Knit.MyModules = game:GetService(&quot;ReplicatedStorage&quot;).MyModules -- Load services/controllers Knit.Start() Copy We can then use these modules elsewhere. For instance: local SomeModule = require(Knit.MyModules.SomeModule) Copy "},{"title":"Controllers","type":0,"sectionRef":"#","url":"docs/controllers","content":"","keywords":""},{"title":"Controllers Defined​","type":1,"pageTitle":"Controllers","url":"docs/controllers#controllers-defined","content":"Controllers are singleton provider objects that serve a specific purpose on the client. For instance, a game might have a CameraController, which manages a custom in-game camera for the player. A controller is essentially the client-side equivalent of a service on the server. For the sake of example, we will develop a CameraController. "},{"title":"Creating Controllers​","type":1,"pageTitle":"Controllers","url":"docs/controllers#creating-controllers","content":"In its simplest form, a controller can be created like so: local CameraController = Knit.CreateController { Name = &quot;CameraController&quot; } return CameraController Copy The Name field is required. The name is how code outside of your controller will find it. This name must be unique from all other controllers. It is best practice to name your variable the same as the controller (e.g. local CameraController matches Name = &quot;CameraController&quot;). The last line (return CameraController) assumes this code is written in a ModuleScript, which is best practice for containing controllers. "},{"title":"Adding Methods​","type":1,"pageTitle":"Controllers","url":"docs/controllers#adding-methods","content":"Controllers are just simple tables at the end of the day. As such, it is very easy to add methods to controllers. function CameraController:LockTo(part) -- TODO: Lock camera end function CameraController:Unlock() -- TODO: Unlock end Copy "},{"title":"Adding Properties​","type":1,"pageTitle":"Controllers","url":"docs/controllers#adding-properties","content":"Again, controllers are just tables. We can simply add in properties as we want. Let's add a property to describe how far away our camera should be from the part we lock onto, and another to describe if the camera is currently locked: CameraController.Distance = 20 CameraController.Locked = false Copy "},{"title":"Adding Basic Behavior​","type":1,"pageTitle":"Controllers","url":"docs/controllers#adding-basic-behavior","content":"Let's add some basic behavior to our controller. When the camera is locked, we should set the CurrentCamera's CameraType to Scriptable, and set the CFrame to the part. When unlocked, we should set the CameraType back to Custom. We will also utilize the Locked property so other code can check if we are currently locked to a part. function CameraController:LockTo(part) local cam = workspace.CurrentCamera self.Locked = true cam.CameraType = Enum.CameraType.Scriptable cam.CFrame = part.CFrame * CFrame.new(0, 0, self.Distance) end function CameraController:Unlock() local cam = workspace.CurrentCamera self.Locked = false cam.CameraType = Enum.CameraType.Custom end Copy "},{"title":"More Behavior​","type":1,"pageTitle":"Controllers","url":"docs/controllers#more-behavior","content":"Right now, when we lock onto a part, we simply set the camera's CFrame once. But what if the part moves? We need to constantly set the camera's CFrame to properly lock onto the part. We can bind to RenderStep to do this. local RunService = game:GetService(&quot;RunService&quot;) CameraController.RenderName = &quot;CustomCamRender&quot; CameraController.Priority = Enum.RenderPriority.Camera.Value function CameraController:LockTo(part) if (self.Locked) then return end -- Stop if already locked local cam = workspace.CurrentCamera self.Locked = true cam.CameraType = Enum.CameraType.Scriptable -- Bind to RenderStep: RunService:BindToRenderStep(self.RenderName, self.Priority, function() cam.CFrame = part.CFrame * CFrame.new(0, 0, self.Distance) end) end function CameraController:Unlock() if (not self.Locked) then return end -- Stop if already unlocked local cam = workspace.CurrentCamera self.Locked = false cam.CameraType = Enum.CameraType.Custom -- Unbind: RunService:UnbindFromRenderStep(self.RenderName) end Copy "},{"title":"Events​","type":1,"pageTitle":"Controllers","url":"docs/controllers#events","content":"What if we want to create an event that gets fired when the camera is locked and unlocked? We can easily do this! Just create a new signal object as a property of the controller, and fire it in our LockTo and Unlock methods. Let's created a LockedChanged signal. It will pass true when locked and false when unlocked. local Signal = require(Knit.Util.Signal) CameraController.LockedChanged = Signal.new() function CameraController:LockTo(part) -- Other code... self.LockedChanged:Fire(true) end function CameraController:Unlock() -- Other code... self.LockedChanged:Fire(false) end Copy Other code could then listen in for that event: -- Somewhere else on the client local CameraController = Knit.GetController(&quot;CameraController&quot;) CameraController.LockedChanged:Connect(function(isLocked) print(isLocked and &quot;Camera is now locked&quot; or &quot;Camera was unlocked&quot;) end) Copy "},{"title":"Server Communication​","type":1,"pageTitle":"Controllers","url":"docs/controllers#server-communication","content":"Knit allows client code to access certain server-side service methods and events that have been explicitly exposed. See the Services: Client Communication section for more info. An example of accessing a service on the server might look like such: function CameraController:KnitStart() local SomeService = Knit.GetService(&quot;SomeService&quot;) SomeService:DoSomething() SomeService.SomeEvent:Connect(function(...) end) SomeService.AnotherEvent:Fire(&quot;Some data&quot;) end Copy No client table forces server-only mode If the Client table is omitted from the service, the service will be interpreted as server-side only. This means that the client will not be able to access the service using Knit.GetService on the client if there is no Client table present. "},{"title":"KnitInit and KnitStart​","type":1,"pageTitle":"Controllers","url":"docs/controllers#knitinit-and-knitstart","content":"The KnitInit and KnitStart methods are optional lifecycle methods that can be added to any controller. For more info, check out the service version of this section (which has the same behavior) and the execution model. These methods can be added just like any other method: function CameraController:KnitStart() print(&quot;CameraController KnitStart called&quot;) end function CameraController:KnitInit() print(&quot;CameraController KnitInit called&quot;) end Copy "},{"title":"Execution Model","type":0,"sectionRef":"#","url":"docs/executionmodel","content":"","keywords":""},{"title":"Lifecycle​","type":1,"pageTitle":"Execution Model","url":"docs/executionmodel#lifecycle","content":"The execution model of Knit defines the flow of operations and lifecycle of Knit. Require the Knit moduleCreate services or controllersCall Knit.Start(), which immediately returns a Promise All KnitInit methods are invoked at the same time, and waits for all to finishAll KnitStart methods are invoked at the same time After all KnitStart methods are called, the promise returned by Knit.Start() resolves  On the server, you should have one Script in ServerScriptService. On the client, you should have one LocalScript in PlayerStarterScripts. Each of these scripts should have a similar layout: local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) -- Load services or controllers here Knit.Start():catch(warn) Copy Once services or controllers are created, they persist forever (until the server shuts down or the player leaves). caution Services and controllers cannot be created after Knit.Start() has been called. "},{"title":"Catching KnitInit Errors​","type":1,"pageTitle":"Execution Model","url":"docs/executionmodel#catching-knitinit-errors","content":"Due to the way Promises work, errors that occur within KnitInit methods of services or controllers will be caught as a rejected promise. These can be handled by either grabbing the status after using Await or using the Catch() method: local success, err = Knit.Start():await() if (not success) then -- Handle error error(tostring(err)) end Copy Knit.Start():catch(function(err) -- Handle error warn(tostring(err)) end) Copy "},{"title":"Best Practices​","type":1,"pageTitle":"Execution Model","url":"docs/executionmodel#best-practices","content":"Only one Script on the server should manage loading services and starting KnitOnly one LocalScript on the client should manage loading controllers and starting KnitSplit up services and controllers into their own modulesServices should be kept in either ServerStorage or ServerScriptService to avoid being exposed to the clientCode within KnitInit and within the root scope of the ModuleScript should try to finish ASAP, and should avoid yielding if possibleEvents and methods should never be added to a service's Client table after Knit.Start() has been calledAs shown above in the Catching knitInit Errors section, handling a failure case of Start is the cleanest way to catch errors on startup. "},{"title":"About","type":0,"sectionRef":"#","url":"docs/intro","content":"","keywords":""},{"title":"Why Choose Knit?​","type":1,"pageTitle":"About","url":"docs/intro#why-choose-knit","content":""},{"title":"Structure​","type":1,"pageTitle":"About","url":"docs/intro#structure","content":"Services and controllers are the core of Knit. These objects provide a foundation for Roblox experiences. By orienting core game logic around services and controllers, developers will inherit cleaner organization across codebases and easier maintainability. Services and controllers are easy to create, and provide a built-in networking layer. "},{"title":"Networking Layer​","type":1,"pageTitle":"About","url":"docs/intro#networking-layer","content":"Knit automatically provides networking between the client and services. Since Knit handles the networking infrastructure, developers are not left with the burden of manually creating RemoteEvent and RemoteFunction objects throughout the hierarchy. Each service has the ability to expose specific endpoints to the client through declarative code. "},{"title":"Extensible​","type":1,"pageTitle":"About","url":"docs/intro#extensible","content":"Knit is built to be extensible. Developers write their own bootstrapping code to start and configure Knit, which gives developers the freedom to extend how Knit functions. "},{"title":"For Everyone​","type":1,"pageTitle":"About","url":"docs/intro#for-everyone","content":"From professional game studios to independent developers, Knit offers a powerful and easy-to-use foundation for Roblox experiences. Knit is available from both Wally and from the Roblox library, allowing developers to choose between a Rojo-based or Studio-based workflow. "},{"title":"Widely Used​","type":1,"pageTitle":"About","url":"docs/intro#widely-used","content":"Knit has been battle-tested in the Roblox ecosystem, and has proven itself to be reliable in both stability and scale. Knit is also open-source and encourages developers to contribute to the growth of the framework. "},{"title":"Middleware","type":0,"sectionRef":"#","url":"docs/middleware","content":"","keywords":""},{"title":"Usage​","type":1,"pageTitle":"Middleware","url":"docs/middleware#usage","content":"Middleware is added when Knit is started: Knit.Start({Middleware = {Inbound = {...}, Outbound = {...}}}) or on each service. Each &quot;middleware&quot; item in the tables is a function. On the client, this function takes an array table containing all the arguments passed along. On the server, it is nearly the same, except the first argument before the arguments table is the player. Each function should return a boolean, indicating whether or not to continue to the request/response. If false, an optional variadic list of items can be returned, which will be returned back to the caller (essentially a short-circuit, but still returning data). Client middleware function signature: (args: {any}) -&gt; (boolean, ...)Server middleware function signature: (player: Player, args: {any}) -&gt; (boolean, ...) "},{"title":"Examples​","type":1,"pageTitle":"Middleware","url":"docs/middleware#examples","content":"Logger​ Here's an example on the client which logs all inbound data from the server: local function Logger(args: {any}) print(args) return true end Knit.Start({ Middleware = {Inbound = {Logger}} }) Copy Here's the same thing, but on the server. As you can see, the only difference is that the player argument is added to the middleware function: local function Logger(player: Player, args: {any}) print(player, args) return true end Knit.Start({ Middleware = {Inbound = {Logger}} }) Copy Manipulation​ A more complex example, where any inbound number to the client is multiplied by 2: local function DoubleNumbers(args) for i,v in ipairs(args) do if type(v) == &quot;number&quot; then args[i] *= 2 end end return true end Knit.Start({Middleware = {Inbound = {DoubleNumbers}}}) Copy Per-Service Example​ Middleware can also be targeted per-service, which will override the global level middleware for the given service. -- Server-side: local MyService = Knit.CreateService { Name = &quot;MyService&quot;, Client = {}, Middleware = { Inbound = {Logger}, Outbound = {}, }, } Copy On the client, things look a little different. Middleware is still per-service, not controller, so the definitions of per-service middleware need to go within Knit.Start() on the client: -- Client-side: Knit.Start({ PerServiceMiddleware = { -- Mapped by name of the service MyService = { Inbound = {Logger}, Outbound = {}, }, }, }) Copy Serialization​ Another example, where a simple class is serialized/deserialized on the client before/after remote network communication occurs. A similar setup could be used server-side to complete the loop: ----------------------------------------------------- -- Setup a simple class: local MyClass = {} MyClass.__index = MyClass MyClass.ClassName = &quot;MyClass&quot; function MyClass.new() return setmetatable({ SomeData = &quot;&quot;, }, MyClass) end function MyClass:Serialize() return {_CN = self.ClassName, D = self.SomeData} end function MyClass.deserialize(data) local myClass = MyClass.new() myClass.SomeData = data return myClass end ----------------------------------------------------- -- Setup middleware for class serialization/deserialization on client: local function InboundClass(args) for i,v in ipairs(args) do if type(v) == &quot;table&quot; and v._CN == &quot;MyClass&quot; then args[i] = MyClass.deserialize(v) end end return true end local function OutboundClass(args) for i,v in ipairs(args) do if type(v) == &quot;table&quot; and v.ClassName == &quot;MyClass&quot; then args[i] = v:Serialize() end end return true end Knit.Start({ Middleware = { Inbound = {InboundClass}, Outbound = {OutboundClass}, }, }) Copy "},{"title":"Getting Started","type":0,"sectionRef":"#","url":"docs/gettingstarted","content":"","keywords":""},{"title":"Tutorial Videos​","type":1,"pageTitle":"Getting Started","url":"docs/gettingstarted#tutorial-videos","content":"Knit can be used via two workflows: Roblox Studio and externally with Rojo and Wally. To help explain how Knit is used through both workflows, check out the tutorial videos for each: Knit Tutorial for StudioKnit Tutorial for Rojo/Wally "},{"title":"Install​","type":1,"pageTitle":"Getting Started","url":"docs/gettingstarted#install","content":"Installing Knit is very simple. Just drop the module into ReplicatedStorage. Knit can also be used within a Rojo project. Roblox Studio workflow: Get Knit from the Roblox library.Place Knit directly within ReplicatedStorage. Rojo/Wally workflow: Add Knit to your wally.toml dependency list (e.g. Knit = &quot;sleitnick/knit@^1.4&quot;) Require Knit like any other module grabbed from Wally Wally Not familiar with Wally? Wally is a package manager (like NPM) for the Roblox ecosystem. To get started, check out the Wally repository. "},{"title":"Basic Usage​","type":1,"pageTitle":"Getting Started","url":"docs/gettingstarted#basic-usage","content":"The core usage of Knit is the same from the server and the client. The general pattern is to create a single script on the server and a single script on the client. These scripts will load Knit, create services/controllers, and then start Knit. The most basic usage would look as such: local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) Knit.Start():catch(warn) -- Knit.Start() returns a Promise, so we are catching any errors and feeding it to the built-in 'warn' function -- You could also chain 'await()' to the end to yield until the whole sequence is completed: -- Knit.Start():catch(warn):await() Copy That would be the necessary code on both the server and the client. However, nothing interesting is going to happen. Let's dive into some more examples. "},{"title":"A Simple Service​","type":1,"pageTitle":"Getting Started","url":"docs/gettingstarted#a-simple-service","content":"A service is simply a structure that serves some specific purpose. For instance, a game might have a MoneyService, which manages in-game currency for players. Let's look at a simple example: local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) -- Create the service: local MoneyService = Knit.CreateService { Name = &quot;MoneyService&quot;, } -- Add some methods to the service: function MoneyService:GetMoney(player) -- Do some sort of data fetch local money = someDataStore:GetAsync(&quot;money&quot;) return money end function MoneyService:GiveMoney(player, amount) -- Do some sort of data fetch local money = self:GetMoney(player) money += amount someDataStore:SetAsync(&quot;money&quot;, money) end Knit.Start():catch(warn) Copy note It's better practice to put services and controllers within their own ModuleScript and then require them from your main script. For the sake of simplicity, they are all in one script for these examples. Now we have a little MoneyService that can get and give money to a player. However, only the server can use this at the moment. What if we want clients to fetch how much money they have? To do this, we have to create some client-side code to consume our service. We could create a controller, but it's not necessary for this example. First, we need to expose a method to the client. We can do this by writing methods on the service's Client table: -- Money service on the server ... function MoneyService.Client:GetMoney(player) -- We already wrote this method, so we can just call the other one. -- 'self.Server' will reference back to the root MoneyService. return self.Server:GetMoney(player) end ... Copy We can write client-side code to fetch money from the service: -- Client-side code local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) Knit.Start():catch(warn):await() local MoneyService = Knit.GetService(&quot;MoneyService&quot;) MoneyService:GetMoney():andThen(function(money) print(money) end) -- Don't want to use promises? When you start Knit on the client, -- set the ServicePromises option to false: Copy Turn Off Promises Don't want to use promises when the client calls a service method? Set the ServicePromises option to false when you start Knit on the client: Knit.Start({ServicePromises = false}):catch(warn):await() local MoneyService = Knit.GetService(&quot;MoneyService&quot;) local money = MoneyService:GetMoney() Copy Under the hood, Knit is creating a RemoteFunction bound to the service's GetMoney method. Knit keeps RemoteFunctions and RemoteEvents out of the way so that developers can focus on writing code and not building communication infrastructure. Check out the Services documentation for more info on services. "},{"title":"Util","type":0,"sectionRef":"#","url":"docs/util","content":"","keywords":""},{"title":"Knit via Wally​","type":1,"pageTitle":"Util","url":"docs/util#knit-via-wally","content":"When installing Knit with Wally, developers should pull in utility modules via Wally as required. Knit's utility modules are significantly slimmed down in the Wally release. "},{"title":"Knit via ModuleScript​","type":1,"pageTitle":"Util","url":"docs/util#knit-via-modulescript","content":"Knit comes with a few utility modules. If Knit is being used from the packaged ModuleScript, then the best way to access these modules is via require(Knit.Util.PACKAGE). The following modules are available: Knit.Util.CommKnit.Util.ComponentKnit.Util.EnumListKnit.Util.InputKnit.Util.OptionKnit.Util.SignalKnit.Util.StreamableKnit.Util.TableUtilKnit.Util.TimerKnit.Util.TroveKnit.Util.Promise Below is an example of the Signal class being used in a service: local Signal = require(Knit.Util.Signal) local MyService = Knit.CreateService { Name = &quot;MyService&quot;, SomeSignal = Signal.new(), } Copy "},{"title":"Services","type":0,"sectionRef":"#","url":"docs/services","content":"","keywords":""},{"title":"Services Defined​","type":1,"pageTitle":"Services","url":"docs/services#services-defined","content":"Services are singleton provider objects that serve a specific purpose on the server. For instance, a game might have a PointsService, which manages in-game points for the players. A game might have many services. They will serve as the backbone of a game. For the sake of example, we will slowly develop PointsService to show how a service is constructed. "},{"title":"Creating Services​","type":1,"pageTitle":"Services","url":"docs/services#creating-services","content":"In its simplest form, a service can be created like so: local PointsService = Knit.CreateService { Name = &quot;PointsService&quot;, Client = {} } return PointsService Copy Client table optional The Client table is optional for the constructor. However, it will be added by Knit if left out. For the sake of code clarity, it is recommended to keep it in the constructor as shown above. No client table forces server-only mode If the Client table is omitted, the service will be interpreted as server-side only. This means that the client will not be able to access this service using Knit.GetService on the client. The Name field is required. This name is how code outside of your service will find it. This name must be unique from all other services. It is best practice to name your variable the same as the service name (e.g. local PointsService matches Name = &quot;PointsService&quot;). The last line (return PointsService) assumes this code is written in a ModuleScript, which is best practice for containing services. "},{"title":"Adding methods​","type":1,"pageTitle":"Services","url":"docs/services#adding-methods","content":"Services are just simple tables at the end of the day. As such, it is very easy to add methods to services. function PointsService:AddPoints(player, amount) -- TODO: add points end function PointsService:GetPoints(player) return 0 end Copy "},{"title":"Adding properties​","type":1,"pageTitle":"Services","url":"docs/services#adding-properties","content":"Again, services are just tables. So we can simply add in properties as we want. In our above method, we are returning 0 for GetPoints() because we have nowhere to store/retrieve points. Likewise, our AddPoints() method can't do anything. Let's change that. Let's create a property that holds a table of points per player: PointsService.PointsPerPlayer = {} Copy "},{"title":"Using methods and properties​","type":1,"pageTitle":"Services","url":"docs/services#using-methods-and-properties","content":"Now we can change our AddPoints() and GetPoints() methods to use this field. PointsService.PointsPerPlayer = {} function PointsService:AddPoints(player, amount) local points = self:GetPoints(player) -- Current amount of points points += amount -- Add points self.PointsPerPlayer[player] = points -- Store points end function PointsService:GetPoints(player) local points = self.PointsPerPlayer[player] return points or 0 -- Return 0 if no points found for player end Copy "},{"title":"Using events​","type":1,"pageTitle":"Services","url":"docs/services#using-events","content":"What if we want to fire an event when the amount of points changes? This is easy. We can assign an event named PointsChanged as a property of our service, and have our AddPoints() method fire the event: -- Load the Signal module and create PointsChanged signal: local Signal = require(Knit.Util.Signal) PointsService.PointsChanged = Signal.new() -- Modify AddPoints: function PointsService:AddPoints(player, amount) local points = self:GetPoints(player) points += amount self.PointsPerPlayer[player] = points -- Fire event signal, as long as we actually changed the points: if (amount ~= 0) then self.PointsChanged:Fire(player, points) end end Copy Another service could then listen for the changes on that event: function SomeOtherService:KnitStart() local PointsService = Knit.GetService(&quot;PointsService&quot;) PointsService.PointsChanged:Connect(function(player, points) print(&quot;Points changed for &quot; .. player.Name .. &quot;:&quot;, points) end) end Copy "},{"title":"KnitInit and KnitStart​","type":1,"pageTitle":"Services","url":"docs/services#knitinit-and-knitstart","content":"In that last code snippet, there's an odd KnitStart() method. This is part of the Knit lifecycle (read more under execution model). These methods are optional, but very useful for orchestrating communication between other services. When a service is first created, it is not guaranteed that other services are also created and ready to be used. The KnitInit and KnitStart methods come to save the day! After all services are created and the Knit.Start() method is fired, the KnitInit methods of all services will be fired. From the KnitInit method, we can guarantee that all other services have been created. However, we still cannot guarantee that those services are ready to be consumed. Therefore, we can reference them within the Init step, but we should never use them (e.g. use the methods or events attached to those other services). After all KnitInit methods have finished, all KnitStart methods are then fired. At this point, we can guarantee that all KnitInits are done, and thus can freely access other services. In order to maintain this pattern, be sure to set up your service in the Init method (or earlier; just in the ModuleScript itself). By the time KnitStart methods are being fired, your services should be available for use. "},{"title":"Cleaning Up Unused Memory​","type":1,"pageTitle":"Services","url":"docs/services#cleaning-up-unused-memory","content":"Alright, back to our PointsService! We have a problem... We have created a memory leak! When we add points for a player, we add the player to the table. What happens when the player leaves? Nothing! And that's a problem. That player's data is forever held onto within that PointsPerPlayer table. To fix this, we need to clear out that data when the player leaves. We can use the KnitInit method to hook up to the Players.PlayerRemoving event and remove the data: function PointsService:KnitInit() game:GetService(&quot;Players&quot;).PlayerRemoving:Connect(function(player) -- Clear out the data for the player when the player leaves: self.PointsPerPlayer[player] = nil end) end Copy While memory management is not unique to Knit, it is still an important aspect to consider when making your game. Even a garbage-collected language like Lua can have memory leaks introduced by the developer. "},{"title":"Client Communication​","type":1,"pageTitle":"Services","url":"docs/services#client-communication","content":"Alright, so we can store and add points on the server for a player. But who cares? Players have no visibility to these points at the moment. We need to open a line of communication between our service and the clients (AKA players). This functionality is so fundamental to Knit, that it's where the name came from: The need to knit together communication. This is where we are going to use that Client table defined at the beginning. "},{"title":"Methods​","type":1,"pageTitle":"Services","url":"docs/services#methods","content":"Let's say that we want to create a method that lets players fetch how many points they have, and when their points change. First, let's make a method to fetch points: function PointsService.Client:GetPoints(player) -- We can just call our other method from here: return self.Server:GetPoints(player) end Copy This creates a client-exposed method called GetPoints. Within it, we reach back to our top-level service using self.Server and then invoke our other GetPoints method that we wrote before. In this example, we've basically just created a proxy for another method; however, this will not always be the case. There will be many times where a client method will exist alone without an equivalent server-side-only method. Under the hood, Knit will create a RemoteFunction and bind this method to it. On the client, we could then invoke the service as such: -- From a LocalScript local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) local PointsService = Knit.GetService(&quot;PointsService&quot;) PointsService:GetPoints():andThen(function(points) print(&quot;Points for myself:&quot;, points) end) Copy "},{"title":"Signals (Server-to-Client)​","type":1,"pageTitle":"Services","url":"docs/services#signals-server-to-client","content":"We should also create a signal that we can fire events for the clients when their points change. We can use Knit:CreateSignal() to indicate we want a signal created for the service. local PointsService = Knit.CreateService { Name = &quot;PointsService&quot;, Client = { PointsChanged = Knit.CreateSignal(), -- Create the signal }, } Copy Remote Signal See the RemoteSignal documentation for more info on how to use the RemoteSignal object. Under the hood, Knit is using the Comm module, which is creating a RemoteEvent object linked to this event. This is a two-way signal (like a transceiver), so we can both send and receive data on both the server and the client. We can then modify our AddPoints method again to fire this signal too: function PointsService:AddPoints(player, amount) local points = self:GetPoints(player) points += amount self.PointsPerPlayer[player] = points if amount ~= 0 then self.PointsChanged:Fire(player, points) -- Fire the client signal: self.Client.PointsChanged:Fire(player, points) end end Copy And from the client, we can listen for an event on the signal: -- From a LocalScript local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) local PointsService = Knit.GetService(&quot;PointsService&quot;) PointsService.PointsChanged:Connect(function(points) print(&quot;Points for myself now:&quot;, points) end) Copy "},{"title":"Signals (Client-to-Server)​","type":1,"pageTitle":"Services","url":"docs/services#signals-client-to-server","content":"Signal events can also be fired from the client. This is useful when the client needs to give the server information, but doesn't care about any response from the server. For instance, maybe the client wants to tell the PointsService that it wants some points. This is an odd use-case, but let's just roll with it. We will create another client-exposed signal called GiveMePoints which will randomly give the player points. Again, this is nonsense in the context of an actual game, but useful for example. Let's create the signal on the PointsService: local PointsService = Knit.CreateService { Name = &quot;PointsService&quot;, Client = { PointsChanged = Knit.CreateSignal(), GiveMePoints = Knit.CreateSignal(), -- Create the new signal }, } Copy Now, let's listen for the client to fire this signal. We can hook this up in our KnitInit method: function PointsService:KnitInit() local rng = Random.new() -- Listen for the client to fire this signal, then give random points: self.Client.GiveMePoints:Connect(function(player) local points = rng:NextInteger(0, 10) self:AddPoints(player, points) print(&quot;Gave &quot; .. player.Name .. &quot; &quot; .. points .. &quot; points&quot;) end) -- ...other code for cleaning up player data here end Copy From the client, we can fire the signal like so: -- From a LocalScript local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) local PointsService = Knit.GetService(&quot;PointsService&quot;) -- Fire the signal: PointsService.GiveMePoints:Fire() Copy Client Remote Signal See the ClientRemoteSignal documentation for more info on how to use the ClientRemoteSignal object. "},{"title":"Properties​","type":1,"pageTitle":"Services","url":"docs/services#properties","content":"It is often useful to replicate data to all or individual players. Instead of creating methods and signals to communicate this data, RemoteProperties can be used. For example, let's refactor the AddPoints method to set a RemoteProperty of the number of points the player has. The client will then be able to easily read this property: -- Create the RemoteProperty: PointsService.Client.Points = Knit.CreateProperty(0) function PointsService:AddPoints(player, amount) local points = self:GetPoints(player) points += amount self.PointsPerPlayer[player] = points self.Client.Points:SetFor(player, points) end Copy On the client, we can now easily read the Points property: -- LocalScript local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) local PointsService = Knit.GetService(&quot;PointsService&quot;) -- The 'Observe' method will fire for the current value and any time the value changes: PointsService.Points:Observe(function(points) print(&quot;Current number of points:&quot;, points) end) Copy Using Observe is the easiest way to track the value of a RemoteProperty on the client. Remote Property See the RemoteProperty andClientRemotePropertydocumentation for more info on how to use the RemoteProperty and ClientRemoteProperty objects.  "},{"title":"Full Example​","type":1,"pageTitle":"Services","url":"docs/services#full-example","content":""},{"title":"PointsService​","type":1,"pageTitle":"Services","url":"docs/services#pointsservice","content":"At the end of this tutorial, we should have a PointsService that looks something like this: local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) local Signal = require(Knit.Util.Signal) local PointsService = Knit.CreateService { Name = &quot;PointsService&quot;, -- Define some properties: PointsPerPlayer = {}, PointsChanged = Signal.new(), Client = { -- Expose signals to the client: PointsChanged = Knit.CreateSignal(), GiveMePoints = Knit.CreateSignal(), Points = Knit.CreateProperty(0), }, } -- Client exposed GetPoints method: function PointsService.Client:GetPoints(player) return self.Server:GetPoints(player) end -- Add Points: function PointsService:AddPoints(player, amount) local points = self:GetPoints(player) points += amount self.PointsPerPlayer[player] = points if amount ~= 0 then self.PointsChanged:Fire(player, points) self.Client.PointsChanged:Fire(player, points) end self.Client.Points:SetFor(player, points) end -- Get Points: function PointsService:GetPoints(player) local points = self.PointsPerPlayer[player] return points or 0 end -- Initialize function PointsService:KnitInit() local rng = Random.new() -- Give player random amount of points: self.Client.GiveMePoints:Connect(function(player) local points = rng:NextInteger(0, 10) self:AddPoints(player, points) print(&quot;Gave &quot; .. player.Name .. &quot; &quot; .. points .. &quot; points&quot;) end) -- Clean up data when player leaves: game:GetService(&quot;Players&quot;).PlayerRemoving:Connect(function(player) self.PointsPerPlayer[player] = nil end) end return PointsService Copy "},{"title":"Client Consumer​","type":1,"pageTitle":"Services","url":"docs/services#client-consumer","content":"Example of client-side LocalScript consuming the PointsService: -- From a LocalScript local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) Knit.Start():catch(warn):await() local PointsService = Knit.GetService(&quot;PointsService&quot;) local function PointsChanged(points) print(&quot;My points:&quot;, points) end -- Get points and listen for changes: PointsService:GetPoints():andThen(PointsChanged) PointsService.PointsChanged:Connect(PointsChanged) -- Ask server to give points randomly: PointsService.GiveMePoints:Fire() Copy "},{"title":"VS Code Snippets","type":0,"sectionRef":"#","url":"docs/vscodesnippets","content":"","keywords":""},{"title":"Using Snippets​","type":1,"pageTitle":"VS Code Snippets","url":"docs/vscodesnippets#using-snippets","content":"Snippets are a Visual Studio Code feature. Check out the Snippets documentation for more info. Adding Snippets for Lua is very easy. Within Visual Studio, navigate from the toolbar: File -&gt; Preferences -&gt; User SnippetsType in and select lua.jsonWithin the {} braces, include any or all of the snippets belowSave the fileWithin your actual source files, start typing a prefix (e.g. &quot;knit&quot;) and select the autocompleted snippet to paste it inDepending on the snippet, parts of the pasted code will be selected and can be typed over (e.g. setting the name of a service)  "},{"title":"Knit Snippets​","type":1,"pageTitle":"VS Code Snippets","url":"docs/vscodesnippets#knit-snippets","content":"Below are useful VS Code snippets for Knit. The snippets assume that the Knit module has been placed within ReplicatedStorage. "},{"title":"Knit​","type":1,"pageTitle":"VS Code Snippets","url":"docs/vscodesnippets#knit","content":"Include a require statement for Knit. Snippet &quot;Knit&quot;: { &quot;prefix&quot;: [&quot;knit&quot;], &quot;body&quot;: [&quot;local Knit = require(ReplicatedStorage.Packages.Knit)&quot;], &quot;description&quot;: &quot;Require the Knit module&quot; } Copy Code Result local Knit = require(ReplicatedStorage.Packages.Knit) Copy  "},{"title":"Service​","type":1,"pageTitle":"VS Code Snippets","url":"docs/vscodesnippets#service","content":"Reference a Roblox service. Snippet &quot;Service&quot;: { &quot;prefix&quot;: [&quot;service&quot;], &quot;body&quot;: [&quot;local ${0:Name}Service = game:GetService(\\&quot;${0:Name}Service\\&quot;)&quot;], &quot;description&quot;: &quot;Roblox Service&quot; } Copy Code Result local HttpService = game:GetService(&quot;HttpService&quot;) Copy  "},{"title":"Knit Service​","type":1,"pageTitle":"VS Code Snippets","url":"docs/vscodesnippets#knit-service","content":"Reference Knit, create a service, and return the service. Snippet &quot;Knit Service&quot;: { &quot;prefix&quot;: [&quot;knitservice&quot;], &quot;body&quot;: [ &quot;local Knit = require(ReplicatedStorage.Packages.Knit)&quot;, &quot;&quot;, &quot;local ${0:$TM_FILENAME_BASE} = Knit.CreateService {&quot;, &quot;\\tName = \\&quot;${0:$TM_FILENAME_BASE}\\&quot;,&quot;, &quot;\\tClient = {},&quot;, &quot;}&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}:KnitStart()&quot;, &quot;\\t&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}:KnitInit()&quot;, &quot;\\t&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;return ${0:$TM_FILENAME_BASE}&quot;, &quot;&quot; ], &quot;description&quot;: &quot;Knit Service template&quot; } Copy Code Result local Knit = require(ReplicatedStorage.Packages.Knit) local MyService = Knit.CreateService { Name = &quot;MyService&quot;, Client = {}, } function MyService:KnitStart() end function MyService:KnitInit() end return MyService Copy  "},{"title":"Knit Controller​","type":1,"pageTitle":"VS Code Snippets","url":"docs/vscodesnippets#knit-controller","content":"Reference Knit, create a controller, and return the controller. Snippet &quot;Knit Controller&quot;: { &quot;prefix&quot;: [&quot;knitcontroller&quot;], &quot;body&quot;: [ &quot;local Knit = require(ReplicatedStorage.Packages.Knit)&quot;, &quot;&quot;, &quot;local ${0:$TM_FILENAME_BASE} = Knit.CreateController { Name = \\&quot;${0:$TM_FILENAME_BASE}\\&quot; }&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}:KnitStart()&quot;, &quot;\\t&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}:KnitInit()&quot;, &quot;\\t&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;return ${0:$TM_FILENAME_BASE}&quot;, &quot;&quot; ], &quot;description&quot;: &quot;Knit Controller template&quot; } Copy Code Result local Knit = require(ReplicatedStorage.Packages.Knit) local MyController = Knit.CreateController { Name = &quot;MyController&quot;, } function MyController:KnitStart() end function MyController:KnitInit() end return MyController Copy  "},{"title":"Knit Require​","type":1,"pageTitle":"VS Code Snippets","url":"docs/vscodesnippets#knit-require","content":"Require a module within Knit. Snippet &quot;Knit Require&quot;: { &quot;prefix&quot;: [&quot;knitrequire&quot;], &quot;body&quot;: [&quot;local ${1:Name} = require(Knit.${2:Util}.${1:Name})&quot;], &quot;description&quot;: &quot;Knit Require template&quot; } Copy Code Result local Signal = require(Knit.Util.Signal) Copy  "},{"title":"Lua Class​","type":1,"pageTitle":"VS Code Snippets","url":"docs/vscodesnippets#lua-class","content":"A standard Lua class. Snippet &quot;Class&quot;: { &quot;prefix&quot;: [&quot;class&quot;], &quot;body&quot;: [ &quot;local ${0:$TM_FILENAME_BASE} = {}&quot;, &quot;${0:$TM_FILENAME_BASE}.__index = ${0:$TM_FILENAME_BASE}&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}.new()&quot;, &quot;\\tlocal self = setmetatable({}, ${0:$TM_FILENAME_BASE})&quot;, &quot;\\treturn self&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}:Destroy()&quot;, &quot;\\t&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;return ${0:$TM_FILENAME_BASE}&quot;, &quot;&quot; ], &quot;description&quot;: &quot;Lua Class&quot; } Copy Code Result local MyClass = {} MyClass.__index = MyClass function MyClass.new() local self = setmetatable({}, MyClass) return self end function MyClass:Destroy() end return MyClass Copy  "},{"title":"All​","type":1,"pageTitle":"VS Code Snippets","url":"docs/vscodesnippets#all","content":"All the above snippets together. All Snippets { &quot;Service&quot;: { &quot;prefix&quot;: [&quot;service&quot;], &quot;body&quot;: [&quot;local ${0:Name}Service = game:GetService(\\&quot;${0:Name}Service\\&quot;)&quot;], &quot;description&quot;: &quot;Roblox Service&quot; }, &quot;Class&quot;: { &quot;prefix&quot;: [&quot;class&quot;], &quot;body&quot;: [ &quot;local ${0:$TM_FILENAME_BASE} = {}&quot;, &quot;${0:$TM_FILENAME_BASE}.__index = ${0:$TM_FILENAME_BASE}&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}.new()&quot;, &quot;\\tlocal self = setmetatable({}, ${0:$TM_FILENAME_BASE})&quot;, &quot;\\treturn self&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}:Destroy()&quot;, &quot;\\t&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;return ${0:$TM_FILENAME_BASE}&quot;, &quot;&quot; ], &quot;description&quot;: &quot;Lua Class&quot; }, &quot;Knit&quot;: { &quot;prefix&quot;: [&quot;knit&quot;], &quot;body&quot;: [&quot;local Knit = require(ReplicatedStorage.Packages.Knit)&quot;], &quot;description&quot;: &quot;Require the Knit module&quot; }, &quot;Knit Service&quot;: { &quot;prefix&quot;: [&quot;knitservice&quot;], &quot;body&quot;: [ &quot;local Knit = require(ReplicatedStorage.Packages.Knit)&quot;, &quot;&quot;, &quot;local ${0:$TM_FILENAME_BASE} = Knit.CreateService {&quot;, &quot;\\tName = \\&quot;${0:$TM_FILENAME_BASE}\\&quot;,&quot;, &quot;\\tClient = {},&quot;, &quot;}&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}:KnitStart()&quot;, &quot;\\t&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}:KnitInit()&quot;, &quot;\\t&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;return ${0:$TM_FILENAME_BASE}&quot;, &quot;&quot; ], &quot;description&quot;: &quot;Knit Service template&quot; }, &quot;Knit Controller&quot;: { &quot;prefix&quot;: [&quot;knitcontroller&quot;], &quot;body&quot;: [ &quot;local Knit = require(ReplicatedStorage.Packages.Knit)&quot;, &quot;&quot;, &quot;local ${0:$TM_FILENAME_BASE} = Knit.CreateController { Name = \\&quot;${0:$TM_FILENAME_BASE}\\&quot; }&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}:KnitStart()&quot;, &quot;\\t&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}:KnitInit()&quot;, &quot;\\t&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;return ${0:$TM_FILENAME_BASE}&quot;, &quot;&quot; ], &quot;description&quot;: &quot;Knit Controller template&quot; }, &quot;Knit Require&quot;: { &quot;prefix&quot;: [&quot;knitrequire&quot;], &quot;body&quot;: [&quot;local ${1:Name} = require(Knit.${2:Util}.${1:Name})&quot;], &quot;description&quot;: &quot;Knit Require template&quot; } } Copy "}]